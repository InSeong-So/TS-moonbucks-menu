리액트 컴포넌트를 개발하는 데 필요한 내용

- 케인크를 만드려면 밀가루, 설탕, 계란이 필요하다.
  - 케이크는 밀가루, 설탕, 계란에 의존한다.
    - 케이크의 의존성: 밀가루, 설탕, 계란

- `~의 의존성: ?` 
  - 컴포넌트의 의존성: ?
    - 컴포넌트를 만드려면 ?가 필요하다.

- 필요한 것은 props와 hooks를 통해 전달받고, 이를 기능적 Type으로 분류한다.

- props, import로 가져오는 의존성의 특징은? 이를 특별한 feature로 분류한다.
  - 스타일: 컴포넌트의 CSS 스타일
  - 로직: 컴포넌트에 사용되는 특정 로직, UI조작에 필요한 커스텀 로직, 앱에 필요한 사이드 이펙트를 줄 때 사용
  - 전역 상태: 유저 액션을 통해 초래된 클라이언트의 상태. 로그인, 전체 메뉴 열고 닫기, URI 표현 등
  - 리모트 데이터 스키마: 원격, API 서버에서 내려주는 데이터의 모양. shcema라는 것이 데이터를 담는 그릇이라는 뜻이 있으니 서버에서 내려주는 데이터의 모양이라고 생각

- `스타일, 로직, 전역 상태`를 내 코드 내부로, `리모트 데이터 스키마`를 내 코드 바깥으로 취급한다.

> 여기까지 컴포넌트 구조도를 생각해보자면 이렇습니다.
- 루트 컴포넌트
- 스타일
- 로직
- 전역 상태
- 리모트 데이터 스키마
- 컴포넌트


- 대다수의 제품은 **하나의 특정 동작**을 원한다. **로딩 인디케이터**를 표시하면서 필요한 모든 데이터를 가져오고, 데이터를 사용할 수 있게 되면 전체 뷰를 렌더링한다.
  - 1. 로딩 상태가 각 컴포넌트에 위치하면서 부분적으로 렌더링
  - 2. 로딩 상태가 끝났을 때 모든 컴포넌트가 준비되면서 한 번에 렌더링

- 케이크에 딸기를 새로 얹어본다면?
  - 딸기 뿐 아니라 생크림도 필요하다.
    - 딸기 케이크는 생크림에 추가적으로 의존한다.
      - 딸기 케이크의 숨은 의존성: 생크림

- 컴포넌트에 새로운 `정보`를 추가하려면 새로운 `정보`와 **?**도 필요하다.
  - 정보를 표현하는 컴포넌트의 숨은 의존성: ?

- 일반적인 게시판 모델에서 새로운 정보를 추가하는 상황
  - **리모트 데이터** : article 컴포넌트의 props 수정
  - **컴포넌트** : 렌더링 부분 수정
  - **숨은 의존성** : props 수정
  - **숨은 의존성** : hook 수정
  - `리모트 데이터 스키마`가 가진 숨은 의존성: `루트 컴포넌트`
    - 만약 props 드릴링을 피하기 위해 데이터 저장소를 분리해도 페이지 기반 라우팅을 한다면 루트 컴포넌트에 의존한다.

> 이걸 어케 정리할까용?

- Co-locate, 함께 두기
  - 리팩토링 제 1원칙: Keep Localty, 비슷한 관심사라면 가까운 곳에

  - 네 가지 의존성 중 가장 쉽게 함께 둘 수 있는 것은 무엇일까?
    - 전역 상태: 여러 컴포넌트가 함께 사용하는 것이니 함께 두기는 힘들다.
    - 스타일, 로직: 함께 두기가 쉽게 가능할 것 같으므로 컴포넌트 내부에 내재되도록 합친다. 이를 CSS-in-JS 스타일과 Custom Hooks 로직이라고 하며 Co-location이라고 한다.
    - 만약 한 컴포넌트의 크기가 너무 커진다면 상위/하위의 다른 폴더가 아닌 같은 폴더에 다른 파일로 분리하는 것을 권장한다.
    - 리모트 데이터 스키마: API 서버에서 전송되는 JSON 데이터는 `루트 컴포넌트 -> 다른컴포넌트 -> 내 컴포넌트` 순이다. 만약 props로 데이터를 받는다면 루트 컴포넌트와 **강한 의존성**이 생기게 된다. 이를 개선하려면 props를 통해 id를 받고, 데이터 저장소에서 id를 통해 데이터를 받아오게 하면 의존성을 끊어낼 수 있다.

- Normalization, 정규화(데이터 정리하기)
  - 리팩토링 제 2원칙: Abstraction by Normalization, 데이터를 ID 기반으로 정리하기

  - 모델명과 ID만으로 데이터를 정리한다. normalizr 오픈소스 참고
    - 컴포넌트에서 `3번 초콜릿을 주세요`라는 요청으로 데이터 저장소에 데이터를 요청할 수 있다. 이 때, 숨은 의존성이 생겨나는데, 바로 모델을 상위에서 정확히 알고 있어야 한다는 점이다.
    - 이를 느슨하게 바꾸기 위해서 사용할 방법 중 하나는 GlobalID(또는 Node ID), 도메인 내에세 유일성(Uniqueness)을 갖는 ID 체계
    - 전역 ID는 특별 객체를 식별하기 위해 모델명을 넘길 필요 없이 ID 값만을 가지고 데이터를 유일하게 식별할 수 있도록 하는 체계이다.
    - 통상 모델명과 ID값을 합쳐서 생성하거나, base64 인/디코딩도 할 수 있다. 그 경우 컴포넌트에서 데이터 저장소로 `C#3`만을 요청하면 된다.
    - 이렇게 GlobalID를 활용해 사용할 데이터의 모델 정보마저 컴포넌트 내부에 **함께 둘 수 있게**된다.

    - 여기서 한 발 더 나아가자면 GOI(Global Object Identification, 전역 객체 식별)를 사용하는 것이다.
      - 전역 ID를 통해 API 서버에 요청하면 해당 객체를 가져올 수 있게 하는 API이다. 이를 API를 서버 측에 제공하게 되면 어떤 맥락에서든 해당 객체를 불러올 수 있게된다.
      - 이러한 GOI 객체는 여러 활용 방법이 있다.
        - 첫 번째, 데이터 저장소에 특정 필드가 없을 때: `컴포넌트 -(C#3의 A, B 필드 줘욧)-데이터 저장소-(필드가 없으니 저한테 먼저 줘욧)-API 서버`
          - 이 경우, 해당 컴포넌트가 어떤 필드를 사용하고 있는지를 표현해야 하는데, 이렇게 사용하면 어떤 필드를 해당 컴포넌트에 사용할지 표현할 수 있다.
            ```js
            const article = useNode({
              on: 'Article',
              fields: {
                title: true,
                content: true,
              },
            }, props.articleId)
            ```
          - 먼저 루트 컴포넌트에서 가져온 데이터를 정규화해서 데이터 저장소에 정리하여 넣어 놓는다.
          - 이후 작성된 컴포넌트는 상위 컴포넌트로부터 Global ID를 받게 되고, 데이터 저장소에 Global ID로 데이터를 요청하여 받게 되고, 데이터 저장소에 데이터가 없다면 API 서버에 데이터를 요청하여 데이터 저장소에 저장한 뒤 컴포넌트에 다시 내려준다.

        - 두 번째, 특정 컴포넌트를 새로고침하고 싶을 때: 보통 UI에서 새로고침하는 버튼을 노출하거나, 수정이 일어날 때 refetch가 일어나는 경우가 많다. 이렇게 작성하면 루트/상위 컴포넌트와 관련 없이 refetch 로직을 쉽게 구현할 수 있다.

- Naming, 이름 짓기

  ```js
  interface Props {
    leftImageThumbnailUrl: string
    title: string
    title2: string
    caption: string
    rightDotColor: string
    rightCaption: string
  }
  ```

  - 리팩토링 제 3원칙: Make Explicit, 의존한다면 그대로 드러내기

  - 의존성을 명확하게 나타내서 작성해야 한다.
    - 의존하는 모델을 그대로 드러내기

      ```js
      interface Props {
        userImageThumbnailUrl: string
        userName: string
        userNickname: string
        userTotalFollowerCount: number
        userLastActivityAt: Date
      }
      ```

    - 모델 간의 연결 정보(Graph)를 그대로 드러내기

      ```js
      interface Props {
        user: {
          name: string
          nickname: string
          totalFollowerCount: number
          lastActivityAt: Date
          image: {
            thumbnailUrl: string
          }
        }
      }
      ```
      - 그런데 한 컴포넌트에서 여러 모델의 정보를 표현하는 것은 관심사의 분리가 제대로 이루어지지 않았다는 일종의 신호이기도 하다. 따라서 아래와 같이 분리한다.

        ```js
        interface Props {
          user: {
            name: string
            nickname: string
            totalFollowerCount: number
            lastActivityAt: Date
            image: {
              thumbnailUrl: string
            }
          }
        }

        interface Props {
          image: {
            thumbnailUrl: string
          }
        }
        ```
        - 하지만 상위 컴포넌트가 해당 모양을 정확하게 맞춰 줘야 하므로 상위 컴포넌트와의 의존성이 생길 것이라 예상되고, 재사용하기 힘들 것 같다.
        - 따라서 앞서 소개한 전역 ID를 통해 필요한 객체의 레퍼런스만 받아오게 되면 의존성이 느슨해지면서 훨씬 재사용성이 수월한 컴포넌트로 만들 수 있다.
          ```js
          interface UserCardProps {
            userId: string
          }

          const user = userNode({
            on: 'User',
            fields: {
              name: true,
              nickname: true,
              totalFollowerCount: true,
              lastActivityAt: true,
              image: true,
            },
          }, props.userId)
          ```
          ```js
          interface AvatarProps {
            imageId: string
          }

          const image = userNode({
            on: 'Image',
            fields: {
              thumbnailUrl: true,
            },
          }, props.imageId)
          ```

- Resuse, 재사용하기
  - 컴포넌트를 재사용하는 이유?
    - 개발할 때 편리하기 위함은 너무 1차원적인 생각. 바로 **변경할 때 편리하기 위해**이다. 유지보수하기 편하도록 말이다.

  - 먼저 변경될만한 부분을 미리 예측하고 준비해야 한다. 어떤게 컴포넌트 변화의 방향성을 결정할까? 제품의 성격에 따라 다르지만, 대부분 리모트 데이터 스키마의 변화에 따라 움직인다. 이를 어떻게 대응할까?
    - 기존의 컴포넌트를 재사용할까?: 해당 컴포넌트를 사용하는 곳이 어디인지, 잘 수정되었는지 여러 곳을 테스트하고 페이지만 따로 구분하기 힘드니 대응하기 쉽지 않다. 아무래도 해당 코드가 관여하는 부분이 넓게 퍼져 그만큼 버그 발생 확률도 늘어난다. 즉, 함께 변하면 안되는 것들이 특정 컴포넌트에 함께 존재하면서 발생했던 부작용 이슈를 잘 설명한다. 그러면 함께 변해야 하는 것들과 따로 변해야 하는 것들을 어떻게 구별할 수 있을까? / 컴포넌트를 복사하여 새 컴포넌트로 분리할까?

  - 리팩토링 네 번째 원칙, Separting Components by Model, 모델 기준으로 컴포넌트를 분리하기
    - 코드베이스에 여러 컴포넌트가 있다고 가정해보자. 각 컴포넌트는 미래에 각자 방향대로 변화한다. 다만 우리의 제품은 끊임없이 변화하면서도 유저에게 일관된 경험을 제공해야한다. 유저들이 생각하는 일관적인 경험은 대부분 모델을 기반으로 하기 때문에 변화의 방향성 역시 모델별로 정렬된다. 만약 두 컴포넌트의 의존성이 모델 기준으로 다르다는 것을 인식하고, 앞으로의 변화 방향성을 고려해서 분리해 놓았다면 어땠을까?
    - 변경이 필요한 부분만 변경되므로 컴포넌트의 수정은 매우 쉽게 대응할 수 있게 된다.
    - **같은 모델**을 의존하는 컴포넌트: 재사용
    - **다른 모델**을 의존하는 컴포넌트: 분리
    - 분명 과거 개발 시 이렇게 앱이 변화될 줄 몰랐겠지만, 이는 리모트 데이터 스키마를 주의깊게 살펴보면 미래에 예측 가능한 변화를 확인할 수 있게 된다.
    - 이렇게 되면 미래에 일관성 있게 변화하면서 유저에게 일관된 경험을 제공할 수 있다.